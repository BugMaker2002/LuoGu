## 一、最小生成树
### 最小生成树问题一般对应无向图
### 两个常用算法：Prim算法（适用于稠密图）和Kruskal算法（适用于稀疏图）
### 1.Prim算法
#### 朴素版：适用于稠密图，时间复杂度为O(n)
#### 代码模板：
```
1).输入：一个加权连通图，其中顶点集合为V，边集合为E；
2).初始化：Vnew = {x}，其中x为集合V中的任一节点（起始点），Enew = {},为空；
3).重复下列操作，直到Vnew = V：
a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；
4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。
```
#### 堆优化版（不常用）：适用于稀疏图，时间复杂度为O(mlogn)
### 2.Kruskal算法
#### 时间复杂度为O(mlogm)
#### 代码模板：
```
1 初始化。将所有边都按权值从小到大排序，将每个节点集合号都初始化为自身编号。
2 按排序后的顺序选择权值最小的边（u,v）。
3 如果节点 u 和 v 属于两个不同的连通分支，则将边(u,v)加入边集 TE 中，并将两个连通分支合并。
4 如果选取的边数小于 n-1,则转向步骤2，否则算法结束。
```
## 二、二分图
### 一个图是二分图当且仅当图中不含奇数环
### 染色法（时间复杂度为O(m+n)）和匈牙利算法（时间复杂度为O(mn)，实际运行时间远小于O(mn)）
### 1.染色法
```cpp
bool dfs(int v, int color)
{
    d[v] = color;
    for (int i = h[v]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (d[j] == -1)
        {
            if (!dfs(j, !color))
            {
                return false;
            }
        }
        if (d[j] == color)
        {
            return false;
        }
    }
    return true;
}
```
### 2.匈牙利算法
### 用于求二分图的最大匹配数
```cpp
bool find(int x)
{
    for(int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if(!st[j])
        {
            st[j] = true;
            if(match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
```